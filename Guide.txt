Using nanoflann for exact nearest neighbor search
https://github.com/jlblancoc/nanoflann


valgrind --tool=callgrind ./my_program
kcachegrind callgrind.out


pkill -f "parameter_bridge"
pkill -f "gz"



ros2 run ros_gz_bridge parameter_bridge --ros-args -p config_file:=/home/sohail/jazzy_ws/src/simple_robot/params/ros_gz_bridge.yaml 
ros2 run teleop_twist_keyboard teleop_twist_keyboard 



to run nav2 server run this:
ros2 launch nav2_bringup bringup_launch.py

the action client is in ros2_manager.hpp ---> use nav2 if you have a map or else a simple pure pursuit is enough





#include "nav2_msgs/action/follow_path.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include "nav_msgs/msg/path.hpp"

// Function to convert Eigen::VectorXd nodes to a nav_msgs::msg::Path
nav_msgs::msg::Path createPathFromNodes(const std::vector<Eigen::VectorXd>& nodes) {
    nav_msgs::msg::Path path;
    path.header.stamp = rclcpp::Clock().now();
    path.header.frame_id = "map"; // Assuming your map frame is "map"

    for (const auto& node : nodes) {
        geometry_msgs::msg::PoseStamped pose;
        pose.header = path.header;
        pose.pose.position.x = node(0); // x position
        pose.pose.position.y = node(1); // y position
        pose.pose.orientation.w = 1.0; // No rotation
        path.poses.push_back(pose);
    }

    return path;
}

// Function to follow the path using nav2
void followPath(const nav_msgs::msg::Path& path, std::shared_ptr<rclcpp::Node> node) {
    auto action_client = rclcpp_action::create_client<nav2_msgs::action::FollowPath>(node, "follow_path");

    if (!action_client->wait_for_action_server(std::chrono::seconds(5))) {
        RCLCPP_ERROR(node->get_logger(), "Action server not available after waiting");
        return;
    }

    auto goal_msg = nav2_msgs::action::FollowPath::Goal();
    goal_msg.path = path;

    auto send_goal_options = rclcpp_action::Client<nav2_msgs::action::FollowPath>::SendGoalOptions();
    send_goal_options.goal_response_callback =
        [](std::shared_future<rclcpp_action::ClientGoalHandle<nav2_msgs::action::FollowPath>::SharedPtr> future) {
            auto goal_handle = future.get();
            if (!goal_handle) {
                RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Goal was rejected by server");
            } else {
                RCLCPP_INFO(rclcpp::get_logger("follow_path_client"), "Goal accepted by server, waiting for result");
            }
        };

    send_goal_options.result_callback =
        [](const rclcpp_action::ClientGoalHandle<nav2_msgs::action::FollowPath>::WrappedResult& result) {
            switch (result.code) {
                case rclcpp_action::ResultCode::SUCCEEDED:
                    RCLCPP_INFO(rclcpp::get_logger("follow_path_client"), "Goal succeeded");
                    break;
                case rclcpp_action::ResultCode::ABORTED:
                    RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Goal was aborted");
                    break;
                case rclcpp_action::ResultCode::CANCELED:
                    RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Goal was canceled");
                    break;
                default:
                    RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Unknown result code");
                    break;
            }
        };

    action_client->async_send_goal(goal_msg, send_goal_options);
}

int main(int argc, char **argv) {
    rclcpp::init(argc, argv);

    auto node = std::make_shared<rclcpp::Node>("path_follower");

    // Example nodes (replace with your actual path nodes)
    std::vector<Eigen::VectorXd> nodes = {
        Eigen::Vector2d(0.0, 0.0),
        Eigen::Vector2d(1.0, 0.0),
        Eigen::Vector2d(1.0, 1.0),
        Eigen::Vector2d(2.0, 2.0)
    };

    // Convert nodes to a nav_msgs::msg::Path
    auto path = createPathFromNodes(nodes);

    // Follow the path using nav2
    followPath(path, node);

    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
////////////////////////////////
The reason your RRTX implementation works without explicit obstacle checks during dynamic updates lies in how you handle node invalidation and rewiring:

Proximity-Based Obstacle Detection:
In updateObstacleSamples, you use findSamplesNearObstacles to detect nodes near obstacles. By invalidating these nodes (setting edge distances to INFINITY), you implicitly mark their connected edges as blocked without explicitly checking every edge. This assumes nodes near obstacles sufficiently represent blocked regions.

Edge Invalidation/Revalidation:

Add Obstacles: Nodes in obstacles invalidate their edges, forcing rewiring to bypass them.

Remove Obstacles: Freed nodes recalculate edge distances (but your code skips obstacle checks and assumes edges are now valid). This works if your obstacle updates are perfect (e.g., Gazebo provides exact obstacle positions).

Rewiring and LMC Updates:
The reduceInconsistency and rewireNeighbors functions propagate cost changes through the tree. Invalidated edges are ignored during rewiring, while valid edges (even if previously blocked) are reconsidered when nodes are freed.

Why It Works Without Explicit Checks:
Implicit Obstacle Avoidance: By marking nodes near obstacles as invalid, their edges are excluded from the tree. The rewiring process naturally avoids these regions.

Dense Sampling: With 5000 nodes, the tree likely covers the space densely enough that most obstacle changes are captured by proximity checks on nodes.

Assumption of Perfect Updates: If Gazebo provides accurate obstacle positions, findSamplesNearObstacles ensures nodes/edges near obstacles are invalidated reliably.

Potential Pitfalls:
False Positives/Negatives: If nodes are incorrectly marked as in-obstacle/free, paths might be invalid.

Edge-Level Obstacles: A new obstacle blocking an edge between two valid nodes (not near either node) might go undetected. Your current implementation assumes such cases are rare due to dense sampling.

For robustness, consider adding edge validity checks in removeObstacle using obs_checker_->isObstacleFree(...) when recalculating distances. This would handle edge-level obstacles not captured by node proximity.

///////////////
Besides the above i think the sole reason is the formula i used in the find samples in obstalce which is a simple euclidean distance by using a the max edge length --> i actually invalidate more nodes than necessary, otherwise i have to explicitly obstalce checking
but that made rrtx very fast and on par with fmtx! :) ---> because we do not explicitly obstalce check anymore but fmtx is still using the plan and obstalce checks! --> which mean fmtx must be faster --> i even didn't use a good tree node for fmtx