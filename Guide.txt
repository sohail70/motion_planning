Using nanoflann for exact nearest neighbor search
https://github.com/jlblancoc/nanoflann


valgrind --tool=callgrind ./my_program
valgrind --tool=callgrind --instr-atstart=no  ./test_rrtx2          -->  if want to profile only a speicifc section you have to use this code and also put macros covering the section in code.

kcachegrind callgrind.out


pkill -f "parameter_bridge"
pkill -f "gz"



ros2 run ros_gz_bridge parameter_bridge --ros-args -p config_file:=/home/sohail/jazzy_ws/src/simple_robot/params/ros_gz_bridge.yaml 
ros2 run teleop_twist_keyboard teleop_twist_keyboard 



to run nav2 server run this:
ros2 launch nav2_bringup bringup_launch.py

the action client is in ros2_manager.hpp ---> use nav2 if you have a map or else a simple pure pursuit is enough





#include "nav2_msgs/action/follow_path.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include "nav_msgs/msg/path.hpp"

// Function to convert Eigen::VectorXd nodes to a nav_msgs::msg::Path
nav_msgs::msg::Path createPathFromNodes(const std::vector<Eigen::VectorXd>& nodes) {
    nav_msgs::msg::Path path;
    path.header.stamp = rclcpp::Clock().now();
    path.header.frame_id = "map"; // Assuming your map frame is "map"

    for (const auto& node : nodes) {
        geometry_msgs::msg::PoseStamped pose;
        pose.header = path.header;
        pose.pose.position.x = node(0); // x position
        pose.pose.position.y = node(1); // y position
        pose.pose.orientation.w = 1.0; // No rotation
        path.poses.push_back(pose);
    }

    return path;
}

// Function to follow the path using nav2
void followPath(const nav_msgs::msg::Path& path, std::shared_ptr<rclcpp::Node> node) {
    auto action_client = rclcpp_action::create_client<nav2_msgs::action::FollowPath>(node, "follow_path");

    if (!action_client->wait_for_action_server(std::chrono::seconds(5))) {
        RCLCPP_ERROR(node->get_logger(), "Action server not available after waiting");
        return;
    }

    auto goal_msg = nav2_msgs::action::FollowPath::Goal();
    goal_msg.path = path;

    auto send_goal_options = rclcpp_action::Client<nav2_msgs::action::FollowPath>::SendGoalOptions();
    send_goal_options.goal_response_callback =
        [](std::shared_future<rclcpp_action::ClientGoalHandle<nav2_msgs::action::FollowPath>::SharedPtr> future) {
            auto goal_handle = future.get();
            if (!goal_handle) {
                RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Goal was rejected by server");
            } else {
                RCLCPP_INFO(rclcpp::get_logger("follow_path_client"), "Goal accepted by server, waiting for result");
            }
        };

    send_goal_options.result_callback =
        [](const rclcpp_action::ClientGoalHandle<nav2_msgs::action::FollowPath>::WrappedResult& result) {
            switch (result.code) {
                case rclcpp_action::ResultCode::SUCCEEDED:
                    RCLCPP_INFO(rclcpp::get_logger("follow_path_client"), "Goal succeeded");
                    break;
                case rclcpp_action::ResultCode::ABORTED:
                    RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Goal was aborted");
                    break;
                case rclcpp_action::ResultCode::CANCELED:
                    RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Goal was canceled");
                    break;
                default:
                    RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Unknown result code");
                    break;
            }
        };

    action_client->async_send_goal(goal_msg, send_goal_options);
}

int main(int argc, char **argv) {
    rclcpp::init(argc, argv);

    auto node = std::make_shared<rclcpp::Node>("path_follower");

    // Example nodes (replace with your actual path nodes)
    std::vector<Eigen::VectorXd> nodes = {
        Eigen::Vector2d(0.0, 0.0),
        Eigen::Vector2d(1.0, 0.0),
        Eigen::Vector2d(1.0, 1.0),
        Eigen::Vector2d(2.0, 2.0)
    };

    // Convert nodes to a nav_msgs::msg::Path
    auto path = createPathFromNodes(nodes);

    // Follow the path using nav2
    followPath(path, node);

    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
////////////////////////////////
The reason your RRTX implementation works without explicit obstacle checks during dynamic updates lies in how you handle node invalidation and rewiring:

Proximity-Based Obstacle Detection:
In updateObstacleSamples, you use findSamplesNearObstacles to detect nodes near obstacles. By invalidating these nodes (setting edge distances to INFINITY), you implicitly mark their connected edges as blocked without explicitly checking every edge. This assumes nodes near obstacles sufficiently represent blocked regions.

Edge Invalidation/Revalidation:

Add Obstacles: Nodes in obstacles invalidate their edges, forcing rewiring to bypass them.

Remove Obstacles: Freed nodes recalculate edge distances (but your code skips obstacle checks and assumes edges are now valid). This works if your obstacle updates are perfect (e.g., Gazebo provides exact obstacle positions).

Rewiring and LMC Updates:
The reduceInconsistency and rewireNeighbors functions propagate cost changes through the tree. Invalidated edges are ignored during rewiring, while valid edges (even if previously blocked) are reconsidered when nodes are freed.

Why It Works Without Explicit Checks:
Implicit Obstacle Avoidance: By marking nodes near obstacles as invalid, their edges are excluded from the tree. The rewiring process naturally avoids these regions.

Dense Sampling: With 5000 nodes, the tree likely covers the space densely enough that most obstacle changes are captured by proximity checks on nodes.

Assumption of Perfect Updates: If Gazebo provides accurate obstacle positions, findSamplesNearObstacles ensures nodes/edges near obstacles are invalidated reliably.

Potential Pitfalls:
False Positives/Negatives: If nodes are incorrectly marked as in-obstacle/free, paths might be invalid.

Edge-Level Obstacles: A new obstacle blocking an edge between two valid nodes (not near either node) might go undetected. Your current implementation assumes such cases are rare due to dense sampling.

For robustness, consider adding edge validity checks in removeObstacle using obs_checker_->isObstacleFree(...) when recalculating distances. This would handle edge-level obstacles not captured by node proximity.

///////////////
Besides the above i think the sole reason is the formula i used in the find samples in obstalce which is a simple euclidean distance by using a the max edge length --> i actually invalidate more nodes than necessary, otherwise i have to explicitly obstalce checking
but that made rrtx very fast and on par with fmtx! :) ---> because we do not explicitly obstalce check anymore but fmtx is still using the plan and obstalce checks! --> which mean fmtx must be faster --> i even didn't use a good tree node for fmtx





///////////////////////////////////////
serious problem:
auto node1 = std::make_shared<FMTXNode>(...);  // node1 owns the FMTXNode
auto node2 = std::make_shared<FMTXNode>(...);  // node2 owns another FMTXNode

// Set raw pointer links
node1->children_.push_back(node2.get());  // node1's children_ points to node2's memory
node2->parent_ = node1.get();             // node2's parent_ points to node1's memory

tree_.push_back(node1);
tree_.push_back(node2);

tree_.clear();  // node1 and node2 are deleted, but:
// node1->children_[0] is now a dangling pointer!
// node2->parent_ is now a dangling pointer!





2. Why Aren’t parent_ and children_ Cleared Automatically?
Raw pointers (FMTXNode*) have no idea when the object they point to is deleted.

They don’t participate in ownership.

They don’t "know" when tree_.clear() happens.

std::vector<FMTXNode*> is just a list of memory addresses.

Clearing tree_ doesn’t magically update these pointers.
///////////////////////////////////////
more info:

i thought when i clear the tree_ these two would also clear!
    std::vector<FMTXNode*> children_; // direct children
    FMTXNode* parent_;
Why Clearing tree_ Doesn't Clear parent_ and children_
You’re encountering a classic C++ ownership misconception. Here’s the breakdown:

1. What Happens When You Call tree_.clear()?
tree_ is a std::vector<std::shared_ptr<FMTXNode>>

clear() destroys all shared_ptrs in the vector.

If no other shared_ptrs reference the nodes, the FMTXNode objects are deleted from memory.

But parent_ and children_ are raw pointers (FMTXNode*)

They are non-owning: They don’t keep the referenced nodes alive.

After tree_.clear(), these pointers become dangling (pointing to freed memory).

Example:
cpp
Copy
auto node1 = std::make_shared<FMTXNode>(...);  // node1 owns the FMTXNode
auto node2 = std::make_shared<FMTXNode>(...);  // node2 owns another FMTXNode

// Set raw pointer links
node1->children_.push_back(node2.get());  // node1's children_ points to node2's memory
node2->parent_ = node1.get();             // node2's parent_ points to node1's memory

tree_.push_back(node1);
tree_.push_back(node2);

tree_.clear();  // node1 and node2 are deleted, but:
// node1->children_[0] is now a dangling pointer!
// node2->parent_ is now a dangling pointer!
2. Why Aren’t parent_ and children_ Cleared Automatically?
Raw pointers (FMTXNode*) have no idea when the object they point to is deleted.

They don’t participate in ownership.

They don’t "know" when tree_.clear() happens.

std::vector<FMTXNode*> is just a list of memory addresses.

Clearing tree_ doesn’t magically update these pointers.

3. What You Expected vs. What Actually Happens
Your Expectation	Reality
"tree_.clear() should also clear parent_ and children_."	tree_.clear() only deletes the shared_ptrs. Raw pointers in children_/parent_ are left dangling.
"I never used new, so I’m safe."	Raw pointers (FMTXNode*) are just as dangerous as new if mismanaged.
4. How to Fix This
Option 1: Use weak_ptr for Non-Owning Links (Recommended)
cpp
Copy
class FMTXNode : public std::enable_shared_from_this<FMTXNode> {
    std::weak_ptr<FMTXNode> parent_;  // Safe non-owning reference
    std::vector<std::weak_ptr<FMTXNode>> children_;  // No dangling pointers!
public:
    void setParent(std::shared_ptr<FMTXNode> parent) {
        parent_ = parent;
        if (auto p = parent_.lock()) {
            p->children_.push_back(shared_from_this());  // Safe!
        }
    }
};
Pros: Automatically handles dangling pointers.

Cons: Slight performance overhead (negligible in most cases).

Option 2: Manually Break Links Before tree_.clear()
cpp
Copy
void clearTree() {
    // Step 1: Nullify all raw pointers
    for (auto& node : tree_) {
        node->parent_ = nullptr;
        node->children_.clear();
    }
    // Step 2: Now safe to clear
    tree_.clear();
}
Pros: No overhead.

Cons: Easy to forget, risky in multithreaded code.

Option 3: Use unique_ptr + Raw Pointers (If You Control All Access)
cpp
Copy
std::vector<std::unique_ptr<FMTXNode>> tree_;

// Guarantee that `tree_` outlives all node operations.
// Raw pointers are safe if you never dereference them after `tree_.clear()`.
5. Key Takeaways for Future C++ Code
Raw pointers (T*) are unsafe by default. They don’t respect ownership.

Always use smart pointers (shared_ptr, unique_ptr) for ownership.

Use weak_ptr for non-owning references (e.g., parent/child links).

Never assume containers will clean up raw pointers. They don’t.

Tools to detect these issues:

valgrind (memory errors)

AddressSanitizer (-fsanitize=address)

Why This Bites Even Experienced Developers
Hidden assumptions: "I didn’t use new, so I’m safe."

Ownership isn’t enforced by the compiler: C++ trusts you to model it correctly.

Debugging is painful: Crashes happen far from the root cause.

What to Remember
Smart pointers = ownership.

Raw pointers = observation only.

tree_.clear() only cares about shared_ptrs, not raw pointers inside nodes.

This is a critical lesson in C++ memory safety! Now you’ll never mix ownership models blindly.




summary of the problem:
Clearing the vector only destroys the memory owned by the unique or shared pointers. However, if those nodes have pointers to one another (like parent or children pointers), those raw pointers won't be automatically updated or nullified. That means other parts of your code could end up referencing invalid memory. The disconnect function is a way to explicitly break those inter-node connections to avoid dangling pointers and undefined behavior.

In short, if no other part of your program keeps a pointer to those nodes (i.e., the tree is the sole owner), you might not strictly need to call disconnect. However, given that your nodes reference each other as part of a graph structure, it's safer to call disconnect before clearing the vector.


better approach --> 

One way to simplify your design is to use smart pointers to manage ownership and relationships automatically. For example:

Use std::shared_ptr for owning pointers and std::weak_ptr for non-owning (back) references.
Instead of having raw pointers for parent and children, store parent pointers as std::weak_ptr and children as std::shared_ptr (or even std::weak_ptr if appropriate). This avoids circular references and ensures that when the owning container (e.g., your tree_ vector) clears, no dangling pointers remain.

Encapsulate relationships in your node class.
By having your node's destructor automatically handle disconnection (or by relying on the weak pointer mechanism), you remove the need for a manual disconnectFromGraph() call. For example, when a node is destroyed, its weak parent pointer does not prevent the parent's destruction, and vice versa.

Example Refactor
Before:

cpp
Copy
Edit
// Raw pointers leading to manual disconnection
FMTXNode* parent_;
std::vector<FMTXNode*> children_;
After:

cpp
Copy
Edit
#include <memory>
#include <vector>

class FMTXNode : public std::enable_shared_from_this<FMTXNode> {
public:
    std::weak_ptr<FMTXNode> parent_;
    std::vector<std::shared_ptr<FMTXNode>> children_;

    // Other members and methods
};
With this setup:

When the tree_ vector (which holds std::shared_ptr<FMTXNode>) is cleared, each node is automatically destroyed.

The parent pointers, being weak, do not extend the lifetime of their children, and the children pointers being shared_ptr ensure that the children are kept alive only if they are owned elsewhere.

Benefits
Automatic Memory Management:
Smart pointers automatically clean up memory when no longer needed.

No Need for Manual Disconnection:
The weak pointers prevent dangling references without requiring an explicit disconnect function.

Safer Code:
It reduces the chance of memory leaks, double frees, or dangling pointers, as ownership is clearly defined.

This design change shifts the responsibility of memory management to the smart pointer mechanism, which can significantly reduce the potential for errors and simplify your cleanup code.