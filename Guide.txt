Using nanoflann for exact nearest neighbor search
https://github.com/jlblancoc/nanoflann


valgrind --tool=callgrind ./my_program
valgrind --tool=callgrind --instr-atstart=no  ./test_rrtx2          -->  if want to profile only a speicifc section you have to use this code and also put macros covering the section in code.

kcachegrind callgrind.out


pkill -f "parameter_bridge"
pkill -f "gz"



ros2 run ros_gz_bridge parameter_bridge --ros-args -p config_file:=/home/sohail/jazzy_ws/src/simple_robot/params/ros_gz_bridge.yaml 
ros2 run teleop_twist_keyboard teleop_twist_keyboard 



to run nav2 server run this:
ros2 launch nav2_bringup bringup_launch.py

the action client is in ros2_manager.hpp ---> use nav2 if you have a map or else a simple pure pursuit is enough





#include "nav2_msgs/action/follow_path.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include "nav_msgs/msg/path.hpp"

// Function to convert Eigen::VectorXd nodes to a nav_msgs::msg::Path
nav_msgs::msg::Path createPathFromNodes(const std::vector<Eigen::VectorXd>& nodes) {
    nav_msgs::msg::Path path;
    path.header.stamp = rclcpp::Clock().now();
    path.header.frame_id = "map"; // Assuming your map frame is "map"

    for (const auto& node : nodes) {
        geometry_msgs::msg::PoseStamped pose;
        pose.header = path.header;
        pose.pose.position.x = node(0); // x position
        pose.pose.position.y = node(1); // y position
        pose.pose.orientation.w = 1.0; // No rotation
        path.poses.push_back(pose);
    }

    return path;
}

// Function to follow the path using nav2
void followPath(const nav_msgs::msg::Path& path, std::shared_ptr<rclcpp::Node> node) {
    auto action_client = rclcpp_action::create_client<nav2_msgs::action::FollowPath>(node, "follow_path");

    if (!action_client->wait_for_action_server(std::chrono::seconds(5))) {
        RCLCPP_ERROR(node->get_logger(), "Action server not available after waiting");
        return;
    }

    auto goal_msg = nav2_msgs::action::FollowPath::Goal();
    goal_msg.path = path;

    auto send_goal_options = rclcpp_action::Client<nav2_msgs::action::FollowPath>::SendGoalOptions();
    send_goal_options.goal_response_callback =
        [](std::shared_future<rclcpp_action::ClientGoalHandle<nav2_msgs::action::FollowPath>::SharedPtr> future) {
            auto goal_handle = future.get();
            if (!goal_handle) {
                RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Goal was rejected by server");
            } else {
                RCLCPP_INFO(rclcpp::get_logger("follow_path_client"), "Goal accepted by server, waiting for result");
            }
        };

    send_goal_options.result_callback =
        [](const rclcpp_action::ClientGoalHandle<nav2_msgs::action::FollowPath>::WrappedResult& result) {
            switch (result.code) {
                case rclcpp_action::ResultCode::SUCCEEDED:
                    RCLCPP_INFO(rclcpp::get_logger("follow_path_client"), "Goal succeeded");
                    break;
                case rclcpp_action::ResultCode::ABORTED:
                    RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Goal was aborted");
                    break;
                case rclcpp_action::ResultCode::CANCELED:
                    RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Goal was canceled");
                    break;
                default:
                    RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Unknown result code");
                    break;
            }
        };

    action_client->async_send_goal(goal_msg, send_goal_options);
}

int main(int argc, char **argv) {
    rclcpp::init(argc, argv);

    auto node = std::make_shared<rclcpp::Node>("path_follower");

    // Example nodes (replace with your actual path nodes)
    std::vector<Eigen::VectorXd> nodes = {
        Eigen::Vector2d(0.0, 0.0),
        Eigen::Vector2d(1.0, 0.0),
        Eigen::Vector2d(1.0, 1.0),
        Eigen::Vector2d(2.0, 2.0)
    };

    // Convert nodes to a nav_msgs::msg::Path
    auto path = createPathFromNodes(nodes);

    // Follow the path using nav2
    followPath(path, node);

    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
////////////////////////////////
The reason your RRTX implementation works without explicit obstacle checks during dynamic updates lies in how you handle node invalidation and rewiring:

Proximity-Based Obstacle Detection:
In updateObstacleSamples, you use findSamplesNearObstacles to detect nodes near obstacles. By invalidating these nodes (setting edge distances to INFINITY), you implicitly mark their connected edges as blocked without explicitly checking every edge. This assumes nodes near obstacles sufficiently represent blocked regions.

Edge Invalidation/Revalidation:

Add Obstacles: Nodes in obstacles invalidate their edges, forcing rewiring to bypass them.

Remove Obstacles: Freed nodes recalculate edge distances (but your code skips obstacle checks and assumes edges are now valid). This works if your obstacle updates are perfect (e.g., Gazebo provides exact obstacle positions).

Rewiring and LMC Updates:
The reduceInconsistency and rewireNeighbors functions propagate cost changes through the tree. Invalidated edges are ignored during rewiring, while valid edges (even if previously blocked) are reconsidered when nodes are freed.

Why It Works Without Explicit Checks:
Implicit Obstacle Avoidance: By marking nodes near obstacles as invalid, their edges are excluded from the tree. The rewiring process naturally avoids these regions.

Dense Sampling: With 5000 nodes, the tree likely covers the space densely enough that most obstacle changes are captured by proximity checks on nodes.

Assumption of Perfect Updates: If Gazebo provides accurate obstacle positions, findSamplesNearObstacles ensures nodes/edges near obstacles are invalidated reliably.

Potential Pitfalls:
False Positives/Negatives: If nodes are incorrectly marked as in-obstacle/free, paths might be invalid.

Edge-Level Obstacles: A new obstacle blocking an edge between two valid nodes (not near either node) might go undetected. Your current implementation assumes such cases are rare due to dense sampling.

For robustness, consider adding edge validity checks in removeObstacle using obs_checker_->isObstacleFree(...) when recalculating distances. This would handle edge-level obstacles not captured by node proximity.

///////////////
Besides the above i think the sole reason is the formula i used in the find samples in obstalce which is a simple euclidean distance by using a the max edge length --> i actually invalidate more nodes than necessary, otherwise i have to explicitly obstalce checking
but that made rrtx very fast and on par with fmtx! :) ---> because we do not explicitly obstalce check anymore but fmtx is still using the plan and obstalce checks! --> which mean fmtx must be faster --> i even didn't use a good tree node for fmtx





///////////////////////////////////////
serious problem:
auto node1 = std::make_shared<FMTNode>(...);  // node1 owns the FMTNode
auto node2 = std::make_shared<FMTNode>(...);  // node2 owns another FMTNode

// Set raw pointer links
node1->children_.push_back(node2.get());  // node1's children_ points to node2's memory
node2->parent_ = node1.get();             // node2's parent_ points to node1's memory

tree_.push_back(node1);
tree_.push_back(node2);

tree_.clear();  // node1 and node2 are deleted, but:
// node1->children_[0] is now a dangling pointer!
// node2->parent_ is now a dangling pointer!





2. Why Aren’t parent_ and children_ Cleared Automatically?
Raw pointers (FMTNode*) have no idea when the object they point to is deleted.

They don’t participate in ownership.

They don’t "know" when tree_.clear() happens.

std::vector<FMTNode*> is just a list of memory addresses.

Clearing tree_ doesn’t magically update these pointers.
///////////////////////////////////////
more info:

i thought when i clear the tree_ these two would also clear!
    std::vector<FMTNode*> children_; // direct children
    FMTNode* parent_;
Why Clearing tree_ Doesn't Clear parent_ and children_
You’re encountering a classic C++ ownership misconception. Here’s the breakdown:

1. What Happens When You Call tree_.clear()?
tree_ is a std::vector<std::shared_ptr<FMTNode>>

clear() destroys all shared_ptrs in the vector.

If no other shared_ptrs reference the nodes, the FMTNode objects are deleted from memory.

But parent_ and children_ are raw pointers (FMTNode*)

They are non-owning: They don’t keep the referenced nodes alive.

After tree_.clear(), these pointers become dangling (pointing to freed memory).

Example:
cpp
Copy
auto node1 = std::make_shared<FMTNode>(...);  // node1 owns the FMTNode
auto node2 = std::make_shared<FMTNode>(...);  // node2 owns another FMTNode

// Set raw pointer links
node1->children_.push_back(node2.get());  // node1's children_ points to node2's memory
node2->parent_ = node1.get();             // node2's parent_ points to node1's memory

tree_.push_back(node1);
tree_.push_back(node2);

tree_.clear();  // node1 and node2 are deleted, but:
// node1->children_[0] is now a dangling pointer!
// node2->parent_ is now a dangling pointer!
2. Why Aren’t parent_ and children_ Cleared Automatically?
Raw pointers (FMTNode*) have no idea when the object they point to is deleted.

They don’t participate in ownership.

They don’t "know" when tree_.clear() happens.

std::vector<FMTNode*> is just a list of memory addresses.

Clearing tree_ doesn’t magically update these pointers.

3. What You Expected vs. What Actually Happens
Your Expectation	Reality
"tree_.clear() should also clear parent_ and children_."	tree_.clear() only deletes the shared_ptrs. Raw pointers in children_/parent_ are left dangling.
"I never used new, so I’m safe."	Raw pointers (FMTNode*) are just as dangerous as new if mismanaged.
4. How to Fix This
Option 1: Use weak_ptr for Non-Owning Links (Recommended)
cpp
Copy
class FMTNode : public std::enable_shared_from_this<FMTNode> {
    std::weak_ptr<FMTNode> parent_;  // Safe non-owning reference
    std::vector<std::weak_ptr<FMTNode>> children_;  // No dangling pointers!
public:
    void setParent(std::shared_ptr<FMTNode> parent) {
        parent_ = parent;
        if (auto p = parent_.lock()) {
            p->children_.push_back(shared_from_this());  // Safe!
        }
    }
};
Pros: Automatically handles dangling pointers.

Cons: Slight performance overhead (negligible in most cases).

Option 2: Manually Break Links Before tree_.clear()
cpp
Copy
void clearTree() {
    // Step 1: Nullify all raw pointers
    for (auto& node : tree_) {
        node->parent_ = nullptr;
        node->children_.clear();
    }
    // Step 2: Now safe to clear
    tree_.clear();
}
Pros: No overhead.

Cons: Easy to forget, risky in multithreaded code.

Option 3: Use unique_ptr + Raw Pointers (If You Control All Access)
cpp
Copy
std::vector<std::unique_ptr<FMTNode>> tree_;

// Guarantee that `tree_` outlives all node operations.
// Raw pointers are safe if you never dereference them after `tree_.clear()`.
5. Key Takeaways for Future C++ Code
Raw pointers (T*) are unsafe by default. They don’t respect ownership.

Always use smart pointers (shared_ptr, unique_ptr) for ownership.

Use weak_ptr for non-owning references (e.g., parent/child links).

Never assume containers will clean up raw pointers. They don’t.

Tools to detect these issues:

valgrind (memory errors)

AddressSanitizer (-fsanitize=address)

Why This Bites Even Experienced Developers
Hidden assumptions: "I didn’t use new, so I’m safe."

Ownership isn’t enforced by the compiler: C++ trusts you to model it correctly.

Debugging is painful: Crashes happen far from the root cause.

What to Remember
Smart pointers = ownership.

Raw pointers = observation only.

tree_.clear() only cares about shared_ptrs, not raw pointers inside nodes.

This is a critical lesson in C++ memory safety! Now you’ll never mix ownership models blindly.




summary of the problem:
Clearing the vector only destroys the memory owned by the unique or shared pointers. However, if those nodes have pointers to one another (like parent or children pointers), those raw pointers won't be automatically updated or nullified. That means other parts of your code could end up referencing invalid memory. The disconnect function is a way to explicitly break those inter-node connections to avoid dangling pointers and undefined behavior.

In short, if no other part of your program keeps a pointer to those nodes (i.e., the tree is the sole owner), you might not strictly need to call disconnect. However, given that your nodes reference each other as part of a graph structure, it's safer to call disconnect before clearing the vector.


better approach --> 

One way to simplify your design is to use smart pointers to manage ownership and relationships automatically. For example:

Use std::shared_ptr for owning pointers and std::weak_ptr for non-owning (back) references.
Instead of having raw pointers for parent and children, store parent pointers as std::weak_ptr and children as std::shared_ptr (or even std::weak_ptr if appropriate). This avoids circular references and ensures that when the owning container (e.g., your tree_ vector) clears, no dangling pointers remain.

Encapsulate relationships in your node class.
By having your node's destructor automatically handle disconnection (or by relying on the weak pointer mechanism), you remove the need for a manual disconnectFromGraph() call. For example, when a node is destroyed, its weak parent pointer does not prevent the parent's destruction, and vice versa.

Example Refactor
Before:

cpp
Copy
Edit
// Raw pointers leading to manual disconnection
FMTNode* parent_;
std::vector<FMTNode*> children_;
After:

cpp
Copy
Edit
#include <memory>
#include <vector>

class FMTNode : public std::enable_shared_from_this<FMTNode> {
public:
    std::weak_ptr<FMTNode> parent_;
    std::vector<std::shared_ptr<FMTNode>> children_;

    // Other members and methods
};
With this setup:

When the tree_ vector (which holds std::shared_ptr<FMTNode>) is cleared, each node is automatically destroyed.

The parent pointers, being weak, do not extend the lifetime of their children, and the children pointers being shared_ptr ensure that the children are kept alive only if they are owned elsewhere.

Benefits
Automatic Memory Management:
Smart pointers automatically clean up memory when no longer needed.

No Need for Manual Disconnection:
The weak pointers prevent dangling references without requiring an explicit disconnect function.

Safer Code:
It reduces the chance of memory leaks, double frees, or dangling pointers, as ownership is clearly defined.

This design change shifts the responsibility of memory management to the smart pointer mechanism, which can significantly reduce the potential for errors and simplify your cleanup code.


-----------------



Copy
Algorithm: FMTX* (Final Integrated Version)
1 V ← {x_init} ∪ SampleFree(n); E ← ∅
2 V_unvisited ← V\{x_init}; V_open ← {x_init}
3 x_robot ← None  # Target robot node
4 c(x_robot) ← ∞  # Initialize robot path cost

5 while V_open ≠ ∅ and (
      (min(V_open) < c(x_robot)) or 
      (c(x_robot) = ∞) or 
      (x_robot ∈ V_unvisited) or 
      (x_robot ∈ V_open)
    ):
    
6   z ← arg min_{y∈V_open} c(y)          # Moved from original line 25
7   N_z ← Near(V\{z}, z, r_n)            # Moved from original line 26
8   V_open_new ← ∅
9   X_near = {x ∈ N_z | x ∈ V_unvisited ∨ c(x) > c(z) + Cost(z,x)}

10  for x ∈ X_near do
11    N_x ← Near(V\{x}, x, r_n)
12    Save(N_x, x)
13    Y_near ← N_x ∩ V_open
14    y_min ← arg min_{y∈Y_near} [c(y) + Cost(y,x)]
    
15    if CollisionFree(y_min, x):
16      if y_min ≠ x.parent:              # Your setParent logic
17        if x.parent ≠ ∅:
18          x.parent.children.remove(x)
19        y_min.children.add(x)
20      c(x) ← c(y_min) + Cost(y_min,x)
21      E ← E ∪ {(y_min, x)}
22      V_open_new ← V_open_new ∪ {x}
23      V_unvisited ← V_unvisited\{x}

24  V_open ← (V_open ∪ V_open_new)\{z}
25  if x_robot ∈ V_open ∪ V_unvisited:    # Update robot path cost
26    c(x_robot) ← GetRobotPathCost() 

27  if V_open = ∅: return Failure

28 return OptimizedPath(x_robot, T = (V, E))


------------------------------
Algorithm: FMTX* (Final Commented Version)
# === Initialization ===
1. Initialize:
    V ← {x_init} ∪ SampleFree(n)          # All nodes (start + random samples)
    E ← ∅                                 # Edges (implicit via neighbor lists)
    V_unvisited ← V \ {x_init}            # Nodes not yet processed
    V_open ← {x_init}                     # Priority queue sorted by node cost
    O_prev ← ∅                            # Track previous obstacles for delta
    x_robot ← ∅                           # Node nearest to actual robot position
    r_n ← ComputeRadius(|V|)              # Neighborhood radius per FMT* formula

# === Main Loop: Replan Until Goal or Timeout ===
2. While RobotNotAtGoal() and V_open ≠ ∅:
3.   # Update robot's nearest node in tree
4.   robot_pos ← GetRobotPosition()
5.   x_robot ← FindNearestNode(robot_pos, V)  # KD-tree lookup
6.   O_new ← GetObstacles()                   # Latest sensor input

# === Handle Newly Added Obstacles ===
7.   for o ∈ (O_new \ O_prev):                # Delta detection
8.     S_conflict ← RadiusSearch(o)           # Nodes in obstacle-inflated zone
9.     for x ∈ S_conflict:
10.      # Invalidate affected edges
11.      for (y, edge) ∈ Near(x):
12.        if EdgeBlocked(x,y):               # Collision check
13.          edge.distance ← ∞                # Infinite traversal cost
14.          y.neighbors[x].distance ← ∞      # Bidirectional edge update
    
15.      # Orphan affected subtree
16.      orphans ← GetDescendants(x)          # All nodes downstream of x
17.      V_unvisited ← V_unvisited ∪ orphans   # Reset processing state
18.      V_open ← V_open \ orphans             # Remove from active queue
19.      ∀n ∈ orphans: c(n)←∞, parent(n)←∅    # Cost/parent reset
    
20.      # Reactivate neighbors for reconsideration
21.      for y ∈ Near(orphans):
22.        if y ∉ (V_open ∪ V_unvisited):
23.          V_open ← V_open ∪ {y}            # Add to processing queue

# === Handle Removed Obstacles ===
24.   for o ∈ (O_prev \ O_new):               # Delta detection
25.     S_freed ← RadiusSearch(o)             # Nodes in freed zone
26.     for x ∈ S_freed:
27.      # Restore previously blocked edges
28.      for (y, edge) ∈ Near(x):
29.        if ¬EdgeBlocked(x,y):              # Obstacle-free check
30.          edge.distance ← Cost(x,y)        # Original traversal cost
31.          y.neighbors[x].distance ← Cost(x,y)
    
32.      # Reactivate node for processing
33.      V_unvisited ← V_unvisited ∪ {x}      # Mark for reprocessing
34.      for y ∈ Near(x):
35.        if y ∉ (V_open ∪ V_unvisited):
36.          V_open ← V_open ∪ {y}            # Add neighbors to queue

37.   O_prev ← O_new                          # Update obstacle memory

# === Core Planning: Expand Lowest-Cost Nodes ===
38.   while V_open ≠ ∅ and (
        (min(V_open) < c(x_robot)) ∨         # Cheaper path exists
        (x_robot ∈ V_unvisited) ∨            # Robot node unprocessed
        (x_robot ∈ V_open)                   # Robot node still queued
      ):
39.     z ← ExtractMin(V_open)               # Expand cheapest node
40.     N_z ← Near(z) ∩ {x | x unvisited OR x has worse cost}  # Candidate nodes
    
41.     for x ∈ N_z:                         # Process each candidate
42.       Y_near ← Near(x) ∩ V_open          # Potential parents
43.       y_min ← arg min[y∈Y_near] (c(y) + Cost(y,x))  # Optimal parent
    
44.       if y_min ≠ ∅ and CollisionFree(y_min, x):
45.         # Rewire tree structure
46.         if parent(x) ≠ ∅: 
47.           parent(x).children.remove(x)   # Remove old parent link
48.         parent(x) ← y_min                # Set new parent
49.         y_min.children.add(x)            # Maintain bidirectional link
        
50.         # Update node cost and state
51.         new_cost ← c(y_min) + Cost(y_min,x)
52.         if new_cost < c(x):              # Only improve costs
53.           c(x) ← new_cost                # Update node cost
54.           if x ∈ V_open: 
55.             UpdatePriority(V_open, x)    # Re-sort queue
56.           else:
57.             V_open ← V_open ∪ {x}        # Add to processing queue
58.           V_unvisited ← V_unvisited \ {x} # Mark as processed

# === Final Path Extraction ===
59. Return ReconstructPath(x_robot)          # Backtrack from robot node to start



--------------------prune case that we do not do collision check in dynamic phase but the above case is also prune but i kept collision free so one don't need collision check in update obstalce------------------------
Algorithm: FMTX* (Complete Validated Version)
# === Initialization ===
1. Initialize:
    V ← {x_init} ∪ SampleFree(n)          # All nodes (start + random samples)
    E ← ∅                                 # Edges (implicit via neighbor lists)
    V_unvisited ← V \ {x_init}            # Nodes not yet processed
    V_open ← {x_init}                     # Priority queue sorted by node cost
    O_prev ← ∅                            # Track previous obstacles for delta
    x_robot ← ∅                           # Node nearest to actual robot position
    r_n ← ComputeRadius(|V|)              # Neighborhood radius per FMT* formula

# === Main Loop: Replan Until Goal or Timeout ===
2. While RobotNotAtGoal() and V_open ≠ ∅:
3.   # Update robot's nearest node in tree
4.   robot_pos ← GetRobotPosition()
5.   x_robot ← FindNearestNode(robot_pos, V)  # KD-tree lookup
6.   O_new ← GetObstacles()                   # Latest sensor input

# === Handle Newly Added Obstacles ===
7.   for o ∈ (O_new \ O_prev):                # Delta detection
8.     S_conflict ← RadiusSearch(o)           # Nodes in obstacle-inflated zone
9.     for x ∈ S_conflict:
10.      # Invalidate affected edges
11.      for (y, edge) ∈ Near(x):
12.        if EdgeBlocked(x,y):               # Collision check
13.          edge.distance ← ∞                # Infinite traversal cost
14.          y.neighbors[x].distance ← ∞      # Bidirectional edge update
    
15.      # Orphan affected subtree
16.      orphans ← GetDescendants(x)          # All nodes downstream of x
17.      V_unvisited ← V_unvisited ∪ orphans   # Reset processing state
18.      V_open ← V_open \ orphans             # Remove from active queue
19.      ∀n ∈ orphans: c(n)←∞, parent(n)←∅    # Cost/parent reset
    
20.      # Reactivate neighbors for reconsideration
21.      for y ∈ Near(orphans):
22.        if y ∉ (V_open ∪ V_unvisited):
23.          V_open ← V_open ∪ {y}            # Add to processing queue

# === Handle Removed Obstacles ===
24.   for o ∈ (O_prev \ O_new):               # Delta detection
25.     S_freed ← RadiusSearch(o)             # Nodes in freed zone
26.     for x ∈ S_freed:
27.      # Remove from open set if present (critical fix)
28.      if x ∈ V_open:
29.        V_open ← V_open \ {x}
    
30.      # Restore previously blocked edges
31.      for (y, edge) ∈ Near(x):
32.        if ¬EdgeBlocked(x,y):              # Obstacle-free check
33.          edge.distance ← Cost(x,y)        # Original traversal cost
34.          y.neighbors[x].distance ← Cost(x,y)
    
35.      # Reactivate node for processing
36.      V_unvisited ← V_unvisited ∪ {x}      # Mark for reprocessing
37.      for y ∈ Near(x):
38.        if y ∉ (V_open ∪ V_unvisited):
39.          V_open ← V_open ∪ {y}            # Add neighbors to queue

# === Core Planning: Expand Lowest-Cost Nodes ===
40.   while V_open ≠ ∅ and (
        (min(V_open) < c(x_robot)) ∨         # Cheaper path exists
        (x_robot ∈ V_unvisited) ∨            # Robot node unprocessed
        (x_robot ∈ V_open)                   # Robot node still queued
      ):
41.     z ← ExtractMin(V_open)               # Expand cheapest node
42.     N_z ← Near(z) ∩ {x | x unvisited OR x has worse cost}  # Candidate nodes
    
43.     for x ∈ N_z:                         # Process each candidate
44.       Y_near ← Near(x) ∩ V_open          # Potential parents
45.       y_min ← arg min[y∈Y_near] (c(y) + Cost(y,x))  # Optimal parent
    
46.       # Collision check only during initial static phase (O_prev=∅)
47.       collision_free ← True
48.       if O_prev = ∅: 
49.         collision_free ← CollisionFree(y_min, x)
        
50.       if y_min ≠ ∅ and collision_free:   # Final edge validation
51.         # Rewire tree structure
52.         if parent(x) ≠ ∅: 
53.           parent(x).children.remove(x)   # Remove old parent link
54.         parent(x) ← y_min                # Set new parent
55.         y_min.children.add(x)            # Maintain bidirectional link
        
56.         # Update node cost and state
57.         new_cost ← c(y_min) + Cost(y_min,x)
58.         if new_cost < c(x):              # Only improve costs
59.           c(x) ← new_cost                # Update node cost
60.           if x ∈ V_open: 
61.             UpdatePriority(V_open, x)    # Re-sort queue
62.           else:
63.             V_open ← V_open ∪ {x}        # Add to processing queue
64.           V_unvisited ← V_unvisited \ {x} # Mark as processed

65.   O_prev ← O_new                          # Update obstacle memory

# === Final Path Extraction ===
66. Return ReconstructPath(x_robot)          # Backtrack from robot node to start