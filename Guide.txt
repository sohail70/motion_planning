Using nanoflann for exact nearest neighbor search
https://github.com/jlblancoc/nanoflann


valgrind --tool=callgrind ./my_program
valgrind --tool=callgrind --instr-atstart=no  ./test_rrtx2          -->  if want to profile only a speicifc section you have to use this code and also put macros covering the section in code.

kcachegrind callgrind.out



take the plots based on this commit(because i added some part like obs cache to fmtx or static obstacles cache etc or some parts i cant even remember that causes more performance hit on fmtx which is just optimal to use):
commit 04bcc8b1892c200f571932e7783c8da7296ffb48
Author: sohail <sohail.e.nia@gmail.com>
Date:   Tue May 27 00:44:12 2025 +0330

    Default to fmt style delayed obstalce check for replanning (prune==false)


another thing is i didnt know about gz sim -s option that would only run the server without the gui. the plots and comparsions are based on running the full gui. i tested without gui in for example
C=1.5 and 10 obstalce with fmtx and the median result were 10ms faster! but all in all it doesnt matter because both FMTx and RRTx were tested with the same condtions!


pkill -f "parameter_bridge"
pkill -f "gz"

taskset -c 0-5 gz sim dynamic_world.sdf 
watch -n 0.5 "ps -eo pid,comm,psr,%cpu --sort=psr | grep -E ' 6 | 7 '"
watch -n 0.5 'ps -eo pid,comm,psr,%cpu --sort=-%cpu | grep -E "test_rrtx|gz|vlc|COMMAND"'

taskset -c 0-5 ros2 run ros_gz_bridge parameter_bridge --ros-args -p config_file:=/home/sohail/jazzy_ws/src/simple_robot/params/ros_gz_bridge.yaml 
ros2 run teleop_twist_keyboard teleop_twist_keyboard 

./fmtx_sim --samples 2000 --factor 1.5 --seed 42 --duration 30


to run nav2 server run this:
ros2 launch nav2_bringup bringup_launch.py

the action client is in ros2_manager.hpp ---> use nav2 if you have a map or else a simple pure pursuit is enough

for only running the gz server without gui:
gz sim -s dynamic_world.sdf    

for f in sim_rrtx_*.csv; do
  mv -- "$f" "2_0_30_$f"
done
for f in sim_rrtx_*.csv; do
  mv -- "$f" "1_0_30_$f"
done

#include "nav2_msgs/action/follow_path.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include "nav_msgs/msg/path.hpp"

// Function to convert Eigen::VectorXd nodes to a nav_msgs::msg::Path
nav_msgs::msg::Path createPathFromNodes(const std::vector<Eigen::VectorXd>& nodes) {
    nav_msgs::msg::Path path;
    path.header.stamp = rclcpp::Clock().now();
    path.header.frame_id = "map"; // Assuming your map frame is "map"

    for (const auto& node : nodes) {
        geometry_msgs::msg::PoseStamped pose;
        pose.header = path.header;
        pose.pose.position.x = node(0); // x position
        pose.pose.position.y = node(1); // y position
        pose.pose.orientation.w = 1.0; // No rotation
        path.poses.push_back(pose);
    }

    return path;
}

// Function to follow the path using nav2
void followPath(const nav_msgs::msg::Path& path, std::shared_ptr<rclcpp::Node> node) {
    auto action_client = rclcpp_action::create_client<nav2_msgs::action::FollowPath>(node, "follow_path");

    if (!action_client->wait_for_action_server(std::chrono::seconds(5))) {
        RCLCPP_ERROR(node->get_logger(), "Action server not available after waiting");
        return;
    }

    auto goal_msg = nav2_msgs::action::FollowPath::Goal();
    goal_msg.path = path;

    auto send_goal_options = rclcpp_action::Client<nav2_msgs::action::FollowPath>::SendGoalOptions();
    send_goal_options.goal_response_callback =
        [](std::shared_future<rclcpp_action::ClientGoalHandle<nav2_msgs::action::FollowPath>::SharedPtr> future) {
            auto goal_handle = future.get();
            if (!goal_handle) {
                RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Goal was rejected by server");
            } else {
                RCLCPP_INFO(rclcpp::get_logger("follow_path_client"), "Goal accepted by server, waiting for result");
            }
        };

    send_goal_options.result_callback =
        [](const rclcpp_action::ClientGoalHandle<nav2_msgs::action::FollowPath>::WrappedResult& result) {
            switch (result.code) {
                case rclcpp_action::ResultCode::SUCCEEDED:
                    RCLCPP_INFO(rclcpp::get_logger("follow_path_client"), "Goal succeeded");
                    break;
                case rclcpp_action::ResultCode::ABORTED:
                    RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Goal was aborted");
                    break;
                case rclcpp_action::ResultCode::CANCELED:
                    RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Goal was canceled");
                    break;
                default:
                    RCLCPP_ERROR(rclcpp::get_logger("follow_path_client"), "Unknown result code");
                    break;
            }
        };

    action_client->async_send_goal(goal_msg, send_goal_options);
}

int main(int argc, char **argv) {
    rclcpp::init(argc, argv);

    auto node = std::make_shared<rclcpp::Node>("path_follower");

    // Example nodes (replace with your actual path nodes)
    std::vector<Eigen::VectorXd> nodes = {
        Eigen::Vector2d(0.0, 0.0),
        Eigen::Vector2d(1.0, 0.0),
        Eigen::Vector2d(1.0, 1.0),
        Eigen::Vector2d(2.0, 2.0)
    };

    // Convert nodes to a nav_msgs::msg::Path
    auto path = createPathFromNodes(nodes);

    // Follow the path using nav2
    followPath(path, node);

    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
////////////////////////////////
The reason your RRTX implementation works without explicit obstacle checks during dynamic updates lies in how you handle node invalidation and rewiring:

Proximity-Based Obstacle Detection:
In updateObstacleSamples, you use findSamplesNearObstacles to detect nodes near obstacles. By invalidating these nodes (setting edge distances to INFINITY), you implicitly mark their connected edges as blocked without explicitly checking every edge. This assumes nodes near obstacles sufficiently represent blocked regions.

Edge Invalidation/Revalidation:

Add Obstacles: Nodes in obstacles invalidate their edges, forcing rewiring to bypass them.

Remove Obstacles: Freed nodes recalculate edge distances (but your code skips obstacle checks and assumes edges are now valid). This works if your obstacle updates are perfect (e.g., Gazebo provides exact obstacle positions).

Rewiring and LMC Updates:
The reduceInconsistency and rewireNeighbors functions propagate cost changes through the tree. Invalidated edges are ignored during rewiring, while valid edges (even if previously blocked) are reconsidered when nodes are freed.

Why It Works Without Explicit Checks:
Implicit Obstacle Avoidance: By marking nodes near obstacles as invalid, their edges are excluded from the tree. The rewiring process naturally avoids these regions.

Dense Sampling: With 5000 nodes, the tree likely covers the space densely enough that most obstacle changes are captured by proximity checks on nodes.

Assumption of Perfect Updates: If Gazebo provides accurate obstacle positions, findSamplesNearObstacles ensures nodes/edges near obstacles are invalidated reliably.

Potential Pitfalls:
False Positives/Negatives: If nodes are incorrectly marked as in-obstacle/free, paths might be invalid.

Edge-Level Obstacles: A new obstacle blocking an edge between two valid nodes (not near either node) might go undetected. Your current implementation assumes such cases are rare due to dense sampling.

For robustness, consider adding edge validity checks in removeObstacle using obs_checker_->isObstacleFree(...) when recalculating distances. This would handle edge-level obstacles not captured by node proximity.

///////////////
Besides the above i think the sole reason is the formula i used in the find samples in obstalce which is a simple euclidean distance by using a the max edge length --> i actually invalidate more nodes than necessary, otherwise i have to explicitly obstalce checking
but that made rrtx very fast and on par with fmtx! :) ---> because we do not explicitly obstalce check anymore but fmtx is still using the plan and obstalce checks! --> which mean fmtx must be faster --> i even didn't use a good tree node for fmtx





///////////////////////////////////////
serious problem:
auto node1 = std::make_shared<FMTNode>(...);  // node1 owns the FMTNode
auto node2 = std::make_shared<FMTNode>(...);  // node2 owns another FMTNode

// Set raw pointer links
node1->children_.push_back(node2.get());  // node1's children_ points to node2's memory
node2->parent_ = node1.get();             // node2's parent_ points to node1's memory

tree_.push_back(node1);
tree_.push_back(node2);

tree_.clear();  // node1 and node2 are deleted, but:
// node1->children_[0] is now a dangling pointer!
// node2->parent_ is now a dangling pointer!





2. Why Aren’t parent_ and children_ Cleared Automatically?
Raw pointers (FMTNode*) have no idea when the object they point to is deleted.

They don’t participate in ownership.

They don’t "know" when tree_.clear() happens.

std::vector<FMTNode*> is just a list of memory addresses.

Clearing tree_ doesn’t magically update these pointers.
///////////////////////////////////////
more info:

i thought when i clear the tree_ these two would also clear!
    std::vector<FMTNode*> children_; // direct children
    FMTNode* parent_;
Why Clearing tree_ Doesn't Clear parent_ and children_
You’re encountering a classic C++ ownership misconception. Here’s the breakdown:

1. What Happens When You Call tree_.clear()?
tree_ is a std::vector<std::shared_ptr<FMTNode>>

clear() destroys all shared_ptrs in the vector.

If no other shared_ptrs reference the nodes, the FMTNode objects are deleted from memory.

But parent_ and children_ are raw pointers (FMTNode*)

They are non-owning: They don’t keep the referenced nodes alive.

After tree_.clear(), these pointers become dangling (pointing to freed memory).

Example:
cpp
Copy
auto node1 = std::make_shared<FMTNode>(...);  // node1 owns the FMTNode
auto node2 = std::make_shared<FMTNode>(...);  // node2 owns another FMTNode

// Set raw pointer links
node1->children_.push_back(node2.get());  // node1's children_ points to node2's memory
node2->parent_ = node1.get();             // node2's parent_ points to node1's memory

tree_.push_back(node1);
tree_.push_back(node2);

tree_.clear();  // node1 and node2 are deleted, but:
// node1->children_[0] is now a dangling pointer!
// node2->parent_ is now a dangling pointer!
2. Why Aren’t parent_ and children_ Cleared Automatically?
Raw pointers (FMTNode*) have no idea when the object they point to is deleted.

They don’t participate in ownership.

They don’t "know" when tree_.clear() happens.

std::vector<FMTNode*> is just a list of memory addresses.

Clearing tree_ doesn’t magically update these pointers.

3. What You Expected vs. What Actually Happens
Your Expectation	Reality
"tree_.clear() should also clear parent_ and children_."	tree_.clear() only deletes the shared_ptrs. Raw pointers in children_/parent_ are left dangling.
"I never used new, so I’m safe."	Raw pointers (FMTNode*) are just as dangerous as new if mismanaged.
4. How to Fix This
Option 1: Use weak_ptr for Non-Owning Links (Recommended)
cpp
Copy
class FMTNode : public std::enable_shared_from_this<FMTNode> {
    std::weak_ptr<FMTNode> parent_;  // Safe non-owning reference
    std::vector<std::weak_ptr<FMTNode>> children_;  // No dangling pointers!
public:
    void setParent(std::shared_ptr<FMTNode> parent) {
        parent_ = parent;
        if (auto p = parent_.lock()) {
            p->children_.push_back(shared_from_this());  // Safe!
        }
    }
};
Pros: Automatically handles dangling pointers.

Cons: Slight performance overhead (negligible in most cases).

Option 2: Manually Break Links Before tree_.clear()
cpp
Copy
void clearTree() {
    // Step 1: Nullify all raw pointers
    for (auto& node : tree_) {
        node->parent_ = nullptr;
        node->children_.clear();
    }
    // Step 2: Now safe to clear
    tree_.clear();
}
Pros: No overhead.

Cons: Easy to forget, risky in multithreaded code.

Option 3: Use unique_ptr + Raw Pointers (If You Control All Access)
cpp
Copy
std::vector<std::unique_ptr<FMTNode>> tree_;

// Guarantee that `tree_` outlives all node operations.
// Raw pointers are safe if you never dereference them after `tree_.clear()`.
5. Key Takeaways for Future C++ Code
Raw pointers (T*) are unsafe by default. They don’t respect ownership.

Always use smart pointers (shared_ptr, unique_ptr) for ownership.

Use weak_ptr for non-owning references (e.g., parent/child links).

Never assume containers will clean up raw pointers. They don’t.

Tools to detect these issues:

valgrind (memory errors)

AddressSanitizer (-fsanitize=address)

Why This Bites Even Experienced Developers
Hidden assumptions: "I didn’t use new, so I’m safe."

Ownership isn’t enforced by the compiler: C++ trusts you to model it correctly.

Debugging is painful: Crashes happen far from the root cause.

What to Remember
Smart pointers = ownership.

Raw pointers = observation only.

tree_.clear() only cares about shared_ptrs, not raw pointers inside nodes.

This is a critical lesson in C++ memory safety! Now you’ll never mix ownership models blindly.




summary of the problem:
Clearing the vector only destroys the memory owned by the unique or shared pointers. However, if those nodes have pointers to one another (like parent or children pointers), those raw pointers won't be automatically updated or nullified. That means other parts of your code could end up referencing invalid memory. The disconnect function is a way to explicitly break those inter-node connections to avoid dangling pointers and undefined behavior.

In short, if no other part of your program keeps a pointer to those nodes (i.e., the tree is the sole owner), you might not strictly need to call disconnect. However, given that your nodes reference each other as part of a graph structure, it's safer to call disconnect before clearing the vector.


better approach --> 

One way to simplify your design is to use smart pointers to manage ownership and relationships automatically. For example:

Use std::shared_ptr for owning pointers and std::weak_ptr for non-owning (back) references.
Instead of having raw pointers for parent and children, store parent pointers as std::weak_ptr and children as std::shared_ptr (or even std::weak_ptr if appropriate). This avoids circular references and ensures that when the owning container (e.g., your tree_ vector) clears, no dangling pointers remain.

Encapsulate relationships in your node class.
By having your node's destructor automatically handle disconnection (or by relying on the weak pointer mechanism), you remove the need for a manual disconnectFromGraph() call. For example, when a node is destroyed, its weak parent pointer does not prevent the parent's destruction, and vice versa.

Example Refactor
Before:

cpp
Copy
Edit
// Raw pointers leading to manual disconnection
FMTNode* parent_;
std::vector<FMTNode*> children_;
After:

cpp
Copy
Edit
#include <memory>
#include <vector>

class FMTNode : public std::enable_shared_from_this<FMTNode> {
public:
    std::weak_ptr<FMTNode> parent_;
    std::vector<std::shared_ptr<FMTNode>> children_;

    // Other members and methods
};
With this setup:

When the tree_ vector (which holds std::shared_ptr<FMTNode>) is cleared, each node is automatically destroyed.

The parent pointers, being weak, do not extend the lifetime of their children, and the children pointers being shared_ptr ensure that the children are kept alive only if they are owned elsewhere.

Benefits
Automatic Memory Management:
Smart pointers automatically clean up memory when no longer needed.

No Need for Manual Disconnection:
The weak pointers prevent dangling references without requiring an explicit disconnect function.

Safer Code:
It reduces the chance of memory leaks, double frees, or dangling pointers, as ownership is clearly defined.

This design change shifts the responsibility of memory management to the smart pointer mechanism, which can significantly reduce the potential for errors and simplify your cleanup code.


-----------------

why my condtion works?

The proof is built on the optimality property of Dijkstra’s algorithm and the priority queue ordering. Once a node’s cost is finalized, no other node can offer a better (cheaper) path to it because:
The algorithm only processes nodes in increasing order of cost.
The algorithm guarantees that when a node’s cost is finalized, it is the smallest possible cost.
Thus, mathematically speaking, once 𝑥
x’s cost has been finalized via z3 ​
 , the condition for updating 
x’s cost via z2 ​
will not be satisfied because no path through z2
can provide a cheaper cost than the path through z3​
even though the cost to root of z2 is less than cost to root of z3! (because the edge distance to z2 is longer than to z3)


# === Initialization ===
1. Initialize:
    V ← {x_init} ∪ SampleFree(n)          # All nodes
    E ← ∅                                 # Edges (implicit via neighbors)
    V_open ← {x_init}                     # Priority queue sorted by g-value
    O_prev ← ∅                            # Previous obstacle state
    x_robot ← ∅                           # Robot's nearest node
    r_n ← ComputeRadius(|V|)              # Neighborhood radius

# === Main Loop ===
2. While RobotNotAtGoal() and V_open ≠ ∅:
3.   # Update robot's node
4.   robot_pos ← GetRobotPosition()
5.   x_robot ← FindNearestNode(robot_pos, V)  # KD-tree search
6.   O_new ← GetObstacles()

    # === Handle Added Obstacles ===
7.   for o ∈ (O_new \ O_prev):            # Delta obstacles
8.     EO ← {(x, y) ∈ E | EdgeIntersectsObstacle(x, y, o)}  # Edges intersecting o
9.     orphans ← ∅                        # Nodes to orphan
10.    for (x, y) ∈ EO:
11.      edge(x, y).distance ← ∞          # Block edge
12.      if parent(x) == y:               # Orphan x if parent edge is blocked
13.        orphans.add(x)
14.      if parent(y) == x:               # Orphan y if parent edge is blocked
15.        orphans.add(y)
16.    # Propagate orphans and descendants
17.    Vc_T ← orphans ∪ GetDescendants(orphans)
18.    for x ∈ Vc_T:
19.      if x ∈ V_open: V_open.remove(x)  # Remove from queue
20.      c(x) ← ∞                         # Reset cost
21.      if parent(x) ≠ ∅:
22.        parent(x).children.remove(x)   # Remove parent link
23.        parent(x) ← ∅
24.    # Reactivate neighbors of orphans
25.    for x ∈ Vc_T:
26.      Y_valid ← {y ∈ Near(x) | c(y) < ∞ ∧ y ∉ V_open}
27.      for y ∈ Y_valid:
28.        V_open.insert(y)             # Add neighbors to queue

    # === Handle Removed Obstacles ===
29.   for o ∈ (O_prev \ O_new):           # Vanished obstacles
30.     EO_prev ← {(v, u) ∈ E | EdgeBlocked(v, u, o)}  # Edges previously blocked by o
31.     EO_new ← {(v, u) ∈ EO_prev | ¬EdgeBlocked(v, u, O_new)}  # Now collision-free
32.     VO ← {v | (v, u) ∈ EO_new} ∪ {u | (v, u) ∈ EO_new}  # Nodes connected to restored edges
33.     # Restore edges
34.     for (v, u) ∈ EO_new:
35.       edge(v, u).distance ← OriginalCost(v, u)  # Restore edge
36.     # Reactivate neighbors
37.     for v ∈ VO:
38.       Y_valid ← {y ∈ Near(v) | c(y) < ∞ ∧ y ∉ V_open}
39.       for y ∈ Y_valid:
40.         V_open.insert(y)              # Add to queue

    # === Core Planning ===
41.   while V_open ≠ ∅ and (c(V_open.top()) < c(x_robot) ∨ x_robot ∈ V_open):
42.     z ← ExtractMin(V_open)
43.     N_z ← {x ∈ Near(z) | c(x) > c(z) + Cost(z,x)} 
44.     for x ∈ N_z:
45.       Y_near ← {y ∈ Near(x) | y ∈ V_open}  
46.       y_min ← arg min[y∈Y_near] (c(y) + Cost(y,x))
47.       collision_free ← True
48.       if O_prev = ∅:                  # Collision check during static planning
49.         collision_free ← CollisionFree(y_min, x)
50.       if y_min ≠ ∅ and collision_free:
51.         if parent(x) ≠ ∅:             # Rewire
52.           parent(x).children.remove(x)
53.         parent(x) ← y_min
54.         c(x) ← c(y_min) + Cost(y_min,x)
55.         if x ∈ V_open: 
56.           UpdatePriority(V_open, x) 
57.         else: 
58.           V_open.insert(x)

    # Update obstacle state
59.   O_prev ← O_new

# === Path Extraction ===
60. Return ReconstructPath(x_robot)




//////////////////////concice version of above///////////////
# === Initialization ===
1. Initialize:
    V ← {x_init} ∪ SampleFree(n)          
    V_open ← {x_init}                     # Priority queue (g-value sorted)
    O_prev ← ∅                            
    x_robot ← ∅                           
    r_n ← ComputeRadius(|V|)              

# === Main Loop ===
2. While RobotNotAtGoal() and V_open ≠ ∅:
3.   robot_pos ← GetRobotPosition()
4.   x_robot ← FindNearestNode(robot_pos, V)  
5.   O_new ← GetObstacles()

    # === Handle Added Obstacles ===
6.   for o ∈ (O_new \ O_prev):            
7.     EO ← {(x, y) ∈ E | EdgeIntersectsObstacle(x, y, o)}  
8.     orphans ← {x, y for (x, y) ∈ EO if parent(x) == y or parent(y) == x}  # ★ Combine orphan check
9.     Vc_T ← orphans ∪ GetDescendants(orphans)
10.    for x ∈ Vc_T:
11.      if x ∈ V_open: V_open.remove(x)  
12.      c(x), parent(x) ← ∞, ∅            # ★ Reset in one line
13.      if parent(x): parent(x).children.remove(x)  
14.    # Reactivate valid neighbors
15.    for x ∈ Vc_T:
16.      for y ∈ {y ∈ Near(x) | c(y) < ∞ ∧ y ∉ V_open}:  # ★ Inline filter
17.        V_open.insert(y)              

    # === Handle Removed Obstacles ===
18.   for o ∈ (O_prev \ O_new):           
19.     EO_prev ← {(v, u) ∈ E | EdgeBlocked(v, u, o)}  
20.     EO_new ← {(v, u) ∈ EO_prev | ¬EdgeBlocked(v, u, O_new)}  
21.     for (v, u) ∈ EO_new: edge(v, u).distance ← OriginalCost(v, u)  
22.     VO ← {v, u for (v, u) ∈ EO_new}  # ★ Flatten nodes
23.     for v ∈ VO:
24.       for y ∈ {y ∈ Near(v) | c(y) < ∞ ∧ y ∉ V_open}:  
25.         V_open.insert(y)              

    # === Core Planning ===
26.   while V_open ≠ ∅ and (c(V_open.top()) < c(x_robot) ∨ x_robot ∈ V_open):
27.     z ← ExtractMin(V_open)
28.     for x ∈ {x ∈ Near(z) | c(x) > c(z) + Cost(z, x)}:  # ★ Inline filter
29.       y_min ← arg min[y ∈ Near(x) ∩ V_open] (c(y) + Cost(y, x))  # ★ Combine Y_near
30.       if y_min and (O_prev ≠ ∅ ∨ CollisionFree(y_min, x)):  # ★ Simplify collision check
31.         if parent(x): parent(x).children.remove(x)  
32.         parent(x), c(x) ← y_min, c(y_min) + Cost(y_min, x)
33.         AddOrUpdate(V_open, x)        # ★ Combine lines 55–58

    # Update obstacle state
34.   O_prev ← O_new

# === Path Extraction ===
35. Return ReconstructPath(x_robot)




/////////////////////modularized//////////////////
# === Initialization ===
1. Initialize:
2.    V ← {x_init} ∪ SampleFree(n)          
3.    V_open ← {x_init}                     # Priority queue (g-value sorted)
4.    O_prev ← ∅                            # Previous obstacle state
5.    x_robot ← ∅                           # Robot's nearest node
6.    r_n ← ComputeRadius(|V|)              # Neighborhood radius

# === Main Loop ===
7. While RobotNotAtGoal() and V_open ≠ ∅:
8.    robot_pos ← GetRobotPosition()
9.    x_robot ← FindNearestNode(robot_pos, V)  
10.   O_new ← GetObstacles()
11.   UpdateObstacles(O_prev, O_new)        # Handle obstacle changes
12.   FMTStarExpand()                       # Core planning logic
13.   O_prev ← O_new                        # Update obstacle state

# === Path Extraction ===
14. Return ReconstructPath(x_robot)

# === Obstacle Handling Functions ===
15. Function UpdateObstacles(O_prev, O_new):
16.    added_obs ← O_new \ O_prev
17.    removed_obs ← O_prev \ O_new
18.    if added_obs ≠ ∅:
19.        AddObstacles(added_obs)          # Invalidate edges, orphan nodes
20.    if removed_obs ≠ ∅:
21.        RemoveObstacles(removed_obs)     # Restore edges, reactivate nodes

22. Function AddObstacles(added_obs):
23.    for o ∈ added_obs:
24.        EO ← {(x, y) ∈ E | EdgeIntersectsObstacle(x, y, o)}
25.        orphans ← {x, y for (x, y) ∈ EO if parent(x) == y or parent(y) == x}
26.        Vc_T ← orphans ∪ GetDescendants(orphans)
27.        for x ∈ Vc_T:                    # Reset costs and parents
28.            if x ∈ V_open: V_open.remove(x)
29.            c(x), parent(x) ← ∞, ∅
30.            if parent(x): parent(x).children.remove(x)
31.        QueueNeighbors(Vc_T)             # Add valid neighbors to queue

32. Function RemoveObstacles(removed_obs):
33.    for o ∈ removed_obs:
34.        EO_prev ← {(v, u) ∈ E | EdgeBlocked(v, u, o)}
35.        EO_new ← {(v, u) ∈ EO_prev | ¬EdgeBlocked(v, u, O_new)}
36.        for (v, u) ∈ EO_new: 
37.            edge(v, u).distance ← OriginalCost(v, u)  # Restore edge cost
38.        VO ← {v, u for (v, u) ∈ EO_new}  # Nodes connected to restored edges
39.        QueueNeighbors(VO)               # Add neighbors to queue

40. Function QueueNeighbors(nodes):
41.    for x ∈ nodes:
42.        for y ∈ Near(x):
43.            if c(y) < ∞ and y ∉ V_open:  # Finite cost and not in queue
44.                V_open.insert(y)         # Explicitly add to queue

# === Core Functions ===
45. Function UpdateParent(x, y_new):
46.    if x.parent == y_new: return
47.    if x.parent: x.parent.children.remove(x)
48.    x.parent ← y_new
49.    if y_new: y_new.children.add(x)

50. Function FMTStarExpand():
51.    while V_open ≠ ∅ ∧ (c(V_open.top()) < c(x_robot) ∨ x_robot ∈ V_open):
52.        z ← ExtractMin(V_open)
53.        for x ∈ {x ∈ Near(z) | c(x) > c(z) + Cost(z, x)}:
54.            y_min ← argmin_{y ∈ Near(x) ∩ V_open} [c(y) + Cost(y, x)]
55.            if y_min ∧ (O_prev ≠ ∅ ∨ CollisionFree(y_min, x)):
56.                new_cost ← c(y_min) + Cost(y_min, x)
57.                UpdateParent(x, y_min)
58.                c(x) ← new_cost
59.                if x ∈ V_open: UpdatePriority(V_open, x)
60.                else: V_open.insert(x)